---
layout: article
title: 链表
tags: ["数据结构", "链表", "leetcode"]
key: "A0004"
mathjax: true

---

# 链表

时间：2022年2月15日15:03:17

```java
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```



## 203.移除链表元素

时间：2022年2月15日14:57:51

评价：简单题目，开始上手链表基本操作

常规的循环操作方式

```java
public ListNode removeElements(ListNode head, int val) {
    ListNode tmpHead = head;
    //单独讨论第一个元素是需要删除的元素的情况
    while (tmpHead != null && tmpHead.val == val) {
        tmpHead = tmpHead.next;
    }
    head = tmpHead;
    while (tmpHead != null) {
        if (tmpHead.next != null && tmpHead.next.val == val) {
            tmpHead.next = tmpHead.next.next;
        } else {
            tmpHead = tmpHead.next;
        }
    }
    return head;
}
```

我个人比较少用的递归方式

~~~java
public ListNode removeElements(ListNode head, int val) {
    if (head == null) {
        return head;
    }
    head.next = removeElements(head.next, val);
    return head.val == val ? head.next : head;
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
~~~



##    707.设计链表

时间：2022-2-15 15:34:03

感谢：相关思维已经有些遗忘。关于链表操作的问题，尽量使用加头结点的方式来完成。不然坐标问题很容易把自己绕晕。。。

心得：通过添加或者单独讨论某种情况，尽量使得程序运行是一个可重复的过程，进而简化逻辑过程。

  ~~~java
	int size;
    private ListNode listNode;

    public MyLinkedList() {
        size = 0;
        listNode = new ListNode(0);
    }

    public int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }

        ListNode tmp = listNode;
        for (int i = 0; i < index + 1; i++) {
            tmp = tmp.next;
        }
        return tmp.val;
    }

    public void addAtHead(int val) {
        addAtIndex(0, val);
    }

    public void addAtTail(int val) {
        addAtIndex(size, val);
    }

    public void addAtIndex(int index, int val) {
        //插入位置大于
        if (index > size)
            return;
        if (index < 0)
            index = 0;
        size++;

        ListNode pred = listNode;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }

        ListNode addTmp = new ListNode();
        addTmp.next = pred.next;
        pred.next = addTmp;
    }

    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }

        size--;

        ListNode pred = listNode;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }

        pred.next = pred.next.next;

    }
作者：LeetCode
链接：https://leetcode-cn.com/problems/design-linked-list/solution/she-ji-lian-biao-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  ~~~

## 206.反转链表

时间：2022-2-15 19:52:28

1、常规做法，通过双指针进行反转，再加一个临时指针用于保存正向链表的头。

~~~java
public ListNode reverseList(ListNode head) {
    if (head == null) {
        return head;
    }
    ListNode first = null;
    ListNode second = head;
    if (second.next == null) {
        return second;
    }
    ListNode tmp = second.next;
    while (true) {
        second.next = first;
        if (tmp == null) {
            break;
        }
        first = second;
        second = tmp;
        tmp = tmp.next;

    }
    return second;
}
//迭代做法:时间复杂度O(n)，空间复杂度O(1)
~~~

2、递归做法

目的：主要用于递归的写法，深入理解递归的思想

时间：2022-2-15 20:15:10

递归的思想：递归主要是分为正向递归与反向递归。正向指的是得到后一个答案的条件之一就是需要前一个答案，类似递进的思想。或者是反向的递归，即前者的答案需要后一个答案作为条件。

具体搭配该题目上，递归版本稍微复杂一些，其关键在于反向工作。假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？

~~~java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode tmpHead = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return tmpHead;
    
}
//递归做法:时间复杂度O(n)，空间复杂度O(n)，主要为递归所使用的栈空间
~~~

## 19.删除倒数第n个节点

时间：2022-2-15 20:33:18

1、常规做法，采用双指针的做法。使得两个指针之间相差n，当后一个指针指向最后一个元素时，第一个元素指向倒数n+1个元素。另外存在着第一个元素指向首节点之前的可能，为了更好的统一性，增加一个单独的虚拟节点

~~~java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode tmpHead = new ListNode(-1);
    tmpHead.next = head;
    ListNode fast = tmpHead.next;
    ListNode slow = tmpHead;
    while (n > 0) {
        n--;
        fast = fast.next;
    }
    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;
    return tmpHead.next;
}
~~~

## 142.环形链表二

时间：2022-2-15 20:56:10

思路：链表快慢指针经典题目

使用a, b, c三个变量进行证明

![image-20220215220242137](D:\MyGithubBlog\_posts\image-20220215220242137.png)

~~~java
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null) {
        slow = slow.next;
        if (fast.next == null) {
            return null;
        }
        fast = fast.next.next;
        if (slow == fast) {
            ListNode ans = head;
            while (slow != ans) {
                ans = ans.next;
                slow = slow.next;
            }
            return ans;
        }
    }
    return null;
}
~~~

---
layout: article
title: LeetCode
tags: "leetcode"
key: "A0006"
mathjax: true
pageview: true
describe: "刷LeetCode题目"
---

# 1、数组

## 209.长度最小的数组

中等难度题目，注意审题，该题目为连续子数组中大于等于target的长度，而不是等于，看错题目，开始怀疑人生。。。

1. 嵌套循环，暴力求解

~~~ java
//209.长度最小的子数组
public int minSubArrayLen(int target, int[] nums) {
    int ans = Integer.MAX_VALUE;
    for (int i = 0; i < nums.length; i++) {
        int count = 0;
        int tmpValue = 0;
        for (int j = i; j < nums.length; j++) {
            tmpValue += nums[j];
            //System.out.println("tmpValue: " + tmpValue);
            count++;
            if (tmpValue >= target) {
                if (count < ans) {
                    ans = count;
                }
                break;
            }
        }
    }
    if (ans == Integer.MAX_VALUE) {
        ans = 0;
    }
    return ans;
}
~~~

### 1.1滑动窗口

同一问题的滑动数组做法

   ```java
   public int minSubArrayLen2(int target, int[] nums) {
       int ans = Integer.MAX_VALUE;
       int i = 0;
       int subLen = 0;
       int tmpValue = 0;
       for (int j = 0; j < nums.length; j++) {
           tmpValue += nums[j];
           while (tmpValue >= target) {
               subLen = (j - i + 1);
               ans = ans < subLen ? ans : subLen;
               tmpValue -= nums[i++];
           }
       }
       return ans == Integer.MAX_VALUE ? 0 : ans;
   }
   ```

## 59.螺旋矩阵二

考察编程的基本能力，但是我目前是比较缺失的——2022年1月26日13:51:29。

模拟螺旋前进的路程，注意循环的边界条件。

**找时间重新做一遍**



# 2、链表

时间：2022年2月15日14:56:35

时间：2022年2月15日15:03:17

```java
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```



## 203.移除链表元素

时间：2022年2月15日14:57:51

评价：简单题目，开始上手链表基本操作

常规的循环操作方式

```java
public ListNode removeElements(ListNode head, int val) {
    ListNode tmpHead = head;
    //单独讨论第一个元素是需要删除的元素的情况
    while (tmpHead != null && tmpHead.val == val) {
        tmpHead = tmpHead.next;
    }
    head = tmpHead;
    while (tmpHead != null) {
        if (tmpHead.next != null && tmpHead.next.val == val) {
            tmpHead.next = tmpHead.next.next;
        } else {
            tmpHead = tmpHead.next;
        }
    }
    return head;
}
```

我个人比较少用的递归方式

~~~java
public ListNode removeElements(ListNode head, int val) {
    if (head == null) {
        return head;
    }
    head.next = removeElements(head.next, val);
    return head.val == val ? head.next : head;
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
~~~



##    707.设计链表

时间：2022-2-15 15:34:03

感谢：相关思维已经有些遗忘。关于链表操作的问题，尽量使用加头结点的方式来完成。不然坐标问题很容易把自己绕晕。。。

心得：通过添加或者单独讨论某种情况，尽量使得程序运行是一个可重复的过程，进而简化逻辑过程。

  ~~~java
  	int size;
      private ListNode listNode;
  
      public MyLinkedList() {
          size = 0;
          listNode = new ListNode(0);
      }
  
      public int get(int index) {
          if (index < 0 || index >= size) {
              return -1;
          }
  
          ListNode tmp = listNode;
          for (int i = 0; i < index + 1; i++) {
              tmp = tmp.next;
          }
          return tmp.val;
      }
  
      public void addAtHead(int val) {
          addAtIndex(0, val);
      }
  
      public void addAtTail(int val) {
          addAtIndex(size, val);
      }
  
      public void addAtIndex(int index, int val) {
          //插入位置大于
          if (index > size)
              return;
          if (index < 0)
              index = 0;
          size++;
  
          ListNode pred = listNode;
          for (int i = 0; i < index; i++) {
              pred = pred.next;
          }
  
          ListNode addTmp = new ListNode();
          addTmp.next = pred.next;
          pred.next = addTmp;
      }
  
      public void deleteAtIndex(int index) {
          if (index < 0 || index >= size) {
              return;
          }
  
          size--;
  
          ListNode pred = listNode;
          for (int i = 0; i < index; i++) {
              pred = pred.next;
          }
  
          pred.next = pred.next.next;
  
      }
  作者：LeetCode
  链接：https://leetcode-cn.com/problems/design-linked-list/solution/she-ji-lian-biao-by-leetcode/
  来源：力扣（LeetCode）
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  ~~~

## 206.反转链表

时间：2022-2-15 19:52:28

1、常规做法，通过双指针进行反转，再加一个临时指针用于保存正向链表的头。

~~~java
public ListNode reverseList(ListNode head) {
    if (head == null) {
        return head;
    }
    ListNode first = null;
    ListNode second = head;
    if (second.next == null) {
        return second;
    }
    ListNode tmp = second.next;
    while (true) {
        second.next = first;
        if (tmp == null) {
            break;
        }
        first = second;
        second = tmp;
        tmp = tmp.next;

    }
    return second;
}
//迭代做法:时间复杂度O(n)，空间复杂度O(1)
~~~

2、递归做法

目的：主要用于递归的写法，深入理解递归的思想

时间：2022-2-15 20:15:10

递归的思想：递归主要是分为正向递归与反向递归。正向指的是得到后一个答案的条件之一就是需要前一个答案，类似递进的思想。或者是反向的递归，即前者的答案需要后一个答案作为条件。

具体搭配该题目上，递归版本稍微复杂一些，其关键在于反向工作。假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？

~~~java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode tmpHead = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return tmpHead;
    
}
//递归做法:时间复杂度O(n)，空间复杂度O(n)，主要为递归所使用的栈空间
~~~

## 19.删除倒数第n个节点

时间：2022-2-15 20:33:18

1、常规做法，采用双指针的做法。使得两个指针之间相差n，当后一个指针指向最后一个元素时，第一个元素指向倒数n+1个元素。另外存在着第一个元素指向首节点之前的可能，为了更好的统一性，增加一个单独的虚拟节点

~~~java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode tmpHead = new ListNode(-1);
    tmpHead.next = head;
    ListNode fast = tmpHead.next;
    ListNode slow = tmpHead;
    while (n > 0) {
        n--;
        fast = fast.next;
    }
    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;
    return tmpHead.next;
}
~~~

## 142.环形链表二

时间：2022-2-15 20:56:10

思路：链表快慢指针经典题目

使用a, b, c三个变量进行证明

![image-20220215220242137](D:\MyGithubBlog\_posts\image-20220215220242137.png)

~~~java
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null) {
        slow = slow.next;
        if (fast.next == null) {
            return null;
        }
        fast = fast.next.next;
        if (slow == fast) {
            ListNode ans = head;
            while (slow != ans) {
                ans = ans.next;
                slow = slow.next;
            }
            return ans;
        }
    }
    return null;
}
~~~

# 3、哈希表

## 哈希表的基本概念

时间：2022-2-16 14:04:18

原意：

~~~
hash

英 [hæʃ]   美 [hæʃ] 

n.剁碎的食物;#号;蔬菜肉丁

vt.把…弄乱;切碎;反复推敲;搞糟
~~~

在计算机学科中：

基本概念：键值对（key-value），即在理想转态下，每一个值会存在一个唯一的key与其对应，在调取该值时，直接通过key来调用即可，查询的时间复杂度为O(1)，但是空间复杂度会存在提高，具体的复杂度一般为O(2n)。

问题：理想状态之下，每一个key会存在一个value，但是仅仅是在理想状态下。现实情况下会存在哈希碰撞的问题，即一个key对应着多个value。

常见的处理哈希碰撞的两种方式：

1、拉链法，即在碰撞的位置采用链表的方式，将所有碰撞的元素都存进去，查找的时候就需要通过链表遍历，因此在设计算法时不能存在链表过长的问题。

2、线性探测法：即从碰撞位置向后探测，找到空位置之后，把碰撞数据填进去。该方法需要保证必须存在哈希空间中必须有空位置。

**注意java中常见的hash结构，面试常考**

## 242.有效的字母异位词

时间：2022-2-16 14:04:30

思路：哈希的思路，但是在具体的实现上，不使用java提供的哈希结构，通过一个记录所有字母的数组即可实现

~~~java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length() || s.length() == 0 || t.length() == 0) {
        return false;
    }
    int[] tmp = new int[26];
    for (int i = 0; i < s.length(); i++) {
        tmp[s.charAt(i) - 'a']++;
    }
    for (int i = 0; i < t.length(); i++) {
        tmp[t.charAt(i) - 'a']--;
        if (tmp[t.charAt(i) - 'a'] < 0) {
            return false;
        }
    }
    for (int i : tmp) {
        if (i != 0) {
            return false;
        }
    }
    return true;
}
~~~

时间：2022-2-16 14:20:39

## 349.两个数组的交集

思路：采用hashmap存储，判断是否存在元素的交集。应该使用hash集合，但是我本人使用较少，需要抓紧时间熟悉

时间：2022-2-16 14:20:24

~~~java
public int[] intersection(int[] nums1, int[] nums2) {
    HashMap<Integer, Integer> tmp = new HashMap<>();
    int count = 0;
    for (int i = 0; i < nums1.length; i++) {
        if (!tmp.containsKey(nums1[i])) {
            tmp.put(nums1[i], 0);
        }
    }
    HashMap<Integer, Integer> tmpAns = new HashMap<>();
    for (int i = 0; i < nums2.length; i++) {
        if (tmp.containsKey(nums2[i]) && !tmpAns.containsKey(nums2[i])) {
            count++;
            tmpAns.put(nums2[i], 0);
        }
    }
    int[] ans = new int[count];
    int j = 0;
    for (Integer key : tmpAns.keySet()) {
        ans[j] = key;
        j++;
    }
    return ans;
}
~~~

时间：2022-2-16 14:44:15

其它思路：排序+双指针

## 1.两数之和

时间：2022-2-16 14:49:05

~~~java
public int[] twoSum(int[] nums, int target) {
    //第一种想法，双指针,不能用，因为输入不是有序的
    HashMap<Integer, Integer> hashMap = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (hashMap.containsKey(target - nums[i]) && hashMap.get(target - nums[i]) != i) {
            return new int[]{hashMap.get(target - nums[i]), i};
        }
        if (!hashMap.containsKey(nums[i])) {
            hashMap.put(nums[i], i);
        }
    }
    int[] ans = new int[2];
    for (int i = 0; i < nums.length; i++) {
        int tmp = target - nums[i];
        if (hashMap.containsKey(tmp) && hashMap.get(tmp) != -1) {
            ans[0] = i;
            ans[1] = hashMap.get(tmp);
            break;
        }
    }
    return ans;
}
~~~

时间：2022-2-16 15:12:31

**做题非常不熟练！！！**做题得先看清楚题目，再开始动手写！！！

~~~java
官方做法
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
    for (int i = 0; i < nums.length; ++i) {
        if (hashtable.containsKey(target - nums[i])) {
            return new int[]{hashtable.get(target - nums[i]), i};
        }
        hashtable.put(nums[i], i);
    }
    return new int[0];
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
~~~

## 454.四数相加

时间：2022-2-16 15:17:10

思路：分组+哈希表。首先将前两个数组元素加和的值与出现的频率记录在hashmap中，再在数组3与数组4的元素组合的值进行计算tmpsum，通过统计-tmpsum在hashmap中出现的频率和，即可得出总的次数。

缺点：时间打败9.37%的用户，空间打败13.38%的用户

~~~java
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums1.length; i++) {
        for (int j = 0; j < nums2.length; j++) {
            int tmp = nums1[i] + nums2[j];
            if (map.containsKey(tmp)) {
                int tmp1 = map.get(tmp);
                tmp1++;
                map.put(tmp, tmp1);
            }else {
                map.put(tmp, 1);
            }
        }
    }
    int count = 0;
    for (int i = 0; i < nums3.length; i++) {
        for (int j = 0; j < nums4.length; j++) {
            int tmp = 0 - nums3[i] - nums4[j];
            if (map.containsKey(tmp)) {
                count += map.get(tmp);
            }
        }
    }
    return count;
}
~~~

时间：2022-2-16 15:32:06

官方思路：相似，但是代码简洁太多

~~~java
public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
    Map<Integer, Integer> countAB = new HashMap<Integer, Integer>();
    for (int u : A) {
        for (int v : B) {
            countAB.put(u + v, countAB.getOrDefault(u + v, 0) + 1);
        }
    }
    int ans = 0;
    for (int u : C) {
        for (int v : D) {
            if (countAB.containsKey(-u - v)) {
                ans += countAB.get(-u - v);
            }
        }
    }
    return ans;
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/4sum-ii/solution/si-shu-xiang-jia-ii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
~~~



## 15.三数之和

时间：一个半小时。。。

思路：开始想用hash做，但是条件太多。。。没做出来，改用官方思路，排序+双指针

~~~java
public List<List<Integer>> threeSum(int[] nums) {
    //        尝试使用哈希的做法来解决这个问题
    //        哈希不太好做。。。条件太多
    //        准备使用排序+双指针的做法
    Arrays.sort(nums);
    List<List<Integer>> ans = new ArrayList<>();
    for (int i = 0; i < nums.length - 2; i++) {
        if (nums[i] > 0) {
            return ans;
        }
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        //System.out.println("chun");
        int last = nums.length - 1;
        int target = 0 - nums[i];
        for (int first = i + 1; first < nums.length; first++) {
            if (first > i + 1 && nums[first] == nums[first - 1]) {
                continue;
            }
            while (first < last && nums[last] + nums[first] > target) {
                last--;
            }

            if (first == last) {
                break;
            }
            if (nums[last] + nums[first] == target) {
                List<Integer> tmpList = new ArrayList<>();
                tmpList.add(nums[i]);
                tmpList.add(nums[first]);
                tmpList.add(nums[last]);
                ans.add(tmpList);

            }
        }


    }
    return ans;
}
~~~

心得：必须非常注意边界条件，有时间重新做这个题！！！

## 18.四数之和

时间：



# 4、字符串

## 344.反转字符串

时间：2022-2-17 10:13:39

```java
public void reverseString(char[] s) {
    if (s.length < 2) {
        return;
    }
    int first = 0;
    int last = s.length - 1;
    while (first < last) {
        char tmp = s[first];
        s[first] = s[last];
        s[last] = tmp;
        first++;
        last--;
    }
}
```

时间：2022-2-17 10:17:24

简单基础题

## 541.反转字符串二

时间：2022-2-18 16:15:49

~~~java
public String reverseStr(String s, int k) {
    StringBuffer tmpAns = new StringBuffer();
    //System.out.println(s + ", " + k);
    int i = 0;
    while (i < s.length()) {
        int end = Math.min(i + k, s.length());
        StringBuffer tmp = new StringBuffer(s.substring(i, end));
        if ((i / k) % 2 == 0) {
            tmp.reverse();
        }
        tmpAns.append(tmp);
        i = end;
    }
    return tmpAns.toString();
}
~~~

时间：2022-2-18 17:18:09

心得：主要是编程思想的学习。不要老是想着模拟整个过程。以本题目为例子，模拟数组的过程，只不过是每次指针都会向后移动k个单位，通过判断指针的奇偶性，即可判断该部分是不是需要进行反转

## 151.反转字符串中的单词

时间：2022-2-18 17:23:44

~~~java
public String reverseWords(String s) {
    StringBuffer tmpAns = new StringBuffer();
    String[] tmp1 = s.split(" ");
    for (int i = tmp1.length - 1; i >= 0; i--) {
        if (!tmp1[i].equals("")) {
            //System.out.println("str: " + tmp1[i]);
            tmpAns.append(tmp1[i]);
            tmpAns.append(" ");
        }
    }
    tmpAns.delete(tmpAns.length() - 1, tmpAns.length());
    //System.out.println(tmpAns.length());
    return tmpAns.toString();
}
~~~



时间：2022-2-18 17:42:00

心得：API调用大法好

## 28.实现strStr()

时间：2022-2-19 21:24:07

思路：经典的KMP算法

~~~java
private int[] getNext(String s) {
    int j = 0;  //j为前缀的末尾，i为后缀的末尾
    int[] next = new int[s.length()];
    next[0] = 0;
    for (int i = 1; i < s.length(); i++) {
        while (j > 0 && s.charAt(j) != s.charAt(i)) {
            j = next[j - 1];
        }
        if (s.charAt(j) == s.charAt(i)) {
            j++;
            next[i] = j;
        }
    }
    return next;
}
public int strStr(String haystack, String needle) {
    if (haystack == null || needle == null) {
        return -1;
    }
    if ((needle.length() == 0)) {
        return 0;
    }
    if (haystack.length() == 0) {
        return -1;
    }
    int[] next = getNext(needle);
    int j = 0;
    int count = 0;
    for (int i = 0; i < haystack.length(); i++) {
        while (j > 0 && haystack.charAt(i) != needle.charAt(j)) {
            j = next[j - 1];
        }
        if (haystack.charAt(i) == needle.charAt(j)) {
            if (j == needle.length() - 1) {
                return i - j;
            }
            j++;
        }
    }
    return -1;
}
~~~



心得：需要注意题目的输入范围。存在着输入的匹配串和模式串长度为0的情况

## 459.重复的子字符串

时间：2022-2-19 21:57:31



# 5、栈与队列

## 232.用栈实现队列

时间：2022-2-20 22:03:48

~~~java
public class MyQueue {

    private Stack<Integer> first;
    private Stack<Integer> second;

    public MyQueue() {
        first = new Stack<>();
        second = new Stack<>();
    }

    public void push(int x) {
        while (!first.empty()) {
            second.push(first.pop());
        }
        second.push(x);
        while (!second.empty()) {
            first.push(second.pop());
        }
    }

    public int pop() {
        if (!first.empty())
            return first.pop();
        return -1;
    }

    public int peek() {
        if (!first.empty())
            return first.peek();
        return -1;
    }

    public boolean empty() {
        return first.empty();
    }
}
~~~

心得：需要进行减少操作的复杂度。使得更多部分的操作更加简单。对于该题目来说，即意味着使得插入操作较为复杂，取出与取出删除操作较为简单。

## 225.用栈实现队列

时间：2022-2-20 22:12:15

```java
public class MyStack {
    private Queue<Integer> s1;
    private Queue<Integer> s2;

    public MyStack() {
        s1 = new LinkedList<>();
        s2 = new LinkedList<>();
    }

    public void push(int x) {
        s2.offer(x);
        while ((!s1.isEmpty())) {
            s2.offer(s1.poll());
        }
        Queue<Integer> tmp = s1;
        s1 = s2;
        s2 = tmp;
    }

    public int pop() {
        return s1.poll();
    }

    public int top() {
        return s1.peek();
    }

    public boolean empty() {
        return s1.isEmpty();
    }
}
```

时间：2022-2-20 22:31:02

思路：思路很明确，但是不小心实例化对象时，将优先队列实例化为了对象。

## 20.有效的括号

思路：经典题目，括号匹配

时间：2022-2-20 22:34:59

~~~java
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '[' || s.charAt(i) == '{' || s.charAt(i) == '(') {
                stack.push(s.charAt(i));
            } else {
                if (stack.empty()) {
                    return false;
                }
                char tmp = stack.pop();
                if (s.charAt(i) == ']' && tmp == '[') {
                    continue;
                } else if (s.charAt(i) == '}' && tmp == '{') {
                    continue;
                } else if (s.charAt(i) == ')' && tmp == '(') {
                    continue;
                } else {
                    return false;
                }

            }
        }
        if (!stack.empty()) {
            return false;
        }
        return true;
    }
~~~

时间：2022-2-20 22:44:27

心得：经典题目，应该还有可优化的空间，但是本次为追求速度的结果。耗费时间不超过十分钟。

## 150.逆波兰表达式

思路：前中后缀表达式

时间：2022-2-23 15:17:21

```java
public int evalRPN(String[] tokens) {
    Stack<String> stack = new Stack<>();
    for (String string : tokens) {
        if (string.equals("+")) {
            int tmp1 = Integer.valueOf(stack.pop());
            int tmp2 = Integer.valueOf(stack.pop());
            Integer tmp3 = tmp2 + tmp1;
            stack.push(tmp3.toString());
        } else if (string.equals("-")) {
            int tmp1 = Integer.valueOf(stack.pop());
            int tmp2 = Integer.valueOf(stack.pop());
            Integer tmp3 = tmp2 - tmp1;
            stack.push(tmp3.toString());
        } else if (string.equals("*")) {
            int tmp1 = Integer.valueOf(stack.pop());
            int tmp2 = Integer.valueOf(stack.pop());
            Integer tmp3 = tmp2 * tmp1;
            stack.push(tmp3.toString());
        } else if (string.equals("/")) {
            int tmp1 = Integer.valueOf(stack.pop());
            int tmp2 = Integer.valueOf(stack.pop());
            Integer tmp3 = tmp2 / tmp1;
            stack.push(tmp3.toString());
        } else {
            stack.push(string);
        }
    }
    return Integer.valueOf(stack.pop());
}
```

时间：2022-2-23 15:47:23

心得：复习一下前中后缀表达式

## 239.滑动窗口最大值

时间：2022-2-23 20:33:14

思路：首先看到困难的难度。。。

1、首先尝试双指针的做法

~~~java
public int[] maxSlidingWindow(int[] nums, int k) {
    int[] ans = new int[nums.length - (k - 1)];
    int first = 0;
    int last = k - 1;
    Queue<int[]> queue = new PriorityQueue<>(new Comparator<int[]>() {
        @Override
        public int compare(int[] o1, int[] o2) {
            if (o1[0] > o2[0]) {
                return -1;
            } else if (o1[0] < o2[0]) {
                return 1;
            } else {
                return 0;
            }
        }
    });
    for (int i = first; i <= last; i++) {
        queue.offer(new int[]{nums[i], i});
    }
    ans[first] = queue.peek()[0];
    while (last < nums.length) {
        last++;
        first++;
        if (last > nums.length - 1) {
            break;
        }
        queue.offer(new int[]{nums[last], last});
        while (queue.peek()[1] < first) {
            queue.poll();
        }
        ans[first] = queue.peek()[0];
    }
    return ans;
}
~~~

时间：2022-2-23 21:17:54

心得：知道只用大顶堆的方法，但是在第一次做的时候，使用了实时维护的大顶堆，这样在最坏情况下的时间复杂度与直接使用暴力方法求一段的最大值是一样的。因此尽量减少维护堆的次数，增加一个位置参数，仅仅在出队列的时候，用位置参数判断该元素是否位于目标段落中。

另外，在官方题解中还有两种做法

## 347.前k个高频词汇

时间：2022-2-23 21:24:48

~~~java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i : nums) {
        map.put(i, map.getOrDefault(i, 0) + 1);
    }
    Queue<int[]> queue = new PriorityQueue<>(new Comparator<int[]>() {
        @Override
        public int compare(int[] o1, int[] o2) {
            if (o1[1] < o2[1]) {
                return 1;
            } else if (o1[1] > o2[1]) {
                return -1;
            } else {
                return 0;
            }
        }
    });
    Iterator iterator = map.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry entry = (Map.Entry) iterator.next();
        Integer key = (Integer) entry.getKey();
        Integer value = (Integer) entry.getValue();
        queue.offer(new int[]{key, value});
    }
    int[] ans = new int[k];
    for (int i = 0; i < k; ++i) {
        int tmp = queue.poll()[0];
        ans[i] = tmp;
    }
    return ans;
}
~~~

时间：2022-2-23 21:46:06

心得：堆，hashmap的综合使用，常规题目

注意，官方还有一种做法

## 42.接雨水

难度：困难

时间：2022-2-23 21:53:44

~~~java
Comparator<int[]> comparator1 = new Comparator<int[]>() {
    @Override
    public int compare(int[] o1, int[] o2) {
        if (o1[0] > o2[0]) {
            return -1;
        } else if (o1[0] < o2[0]) {
            return 1;
        } else {
            return 0;
        }
    }
};
public int trap(int[] height) {
    if (height.length < 3) {
        return 0;
    }
    Queue<int[]> first = new PriorityQueue<>(comparator1);
    Queue<int[]> last = new PriorityQueue<>(comparator1);
    for (int i = height.length - 1; i >= 1; i--) {
        last.offer(new int[]{height[i], i});
    }
    int ans = 0;
    first.offer(new int[]{height[0], 0});
    for (int i = 1; i < height.length - 1; i++) {
        while (true) {
            if (last.peek()[1] < i) {
                last.poll();
            } else {
                break;
            }
        }
        int tmpMin = Integer.min(first.peek()[0], last.peek()[0]);
        //System.out.println("tmpMin: " + tmpMin);
        if (tmpMin > height[i]) {
            //System.out.println("i: " +i + ", height:" + first.peek()[0] +   ", cur: " + height[i] + " height: " + last.peek()[0] + " 差值: " + (tmpMin - height[i]) + ", " +  ans);
            ans += (tmpMin - height[i]);
        }
        first.offer(new int[]{height[i], i});

    }
    return ans;
}
~~~

时间：2022-2-23 23:02:18

心得：通过两个优先队列实现

1、首先是当数组长度小于三，必然不可能有结果

2、每个地方的存水与该元素前后的最高高度有关。根据木桶效应，从该点前后最高的高度中选出一个矮的，与该点高度的差值即为存水量。因此准备一个指针，从第二个开始遍历，另外准备两个优先队列，维护当前所指节点前后的最高高度。

**官方做法，之后还得仔细看！！**

https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/

# 6、二叉树

## 二叉树的基本概念

1、树的基本概念

树是由根结点和若干颗子树构成的。树是由一个集合以及在该集合上定义的一种关系构成的。

　　（1）每个元素称为结点（node）；

　　（2）有一个特定的结点被称为根结点或树根（root）；

　　（3）相关术语：

　　　　 结点的度：一个结点含有的子树的个数

　　　 　 叶子结点或终端结点：度为0的结点

　　　　 节点的层数： 树根到节点的路径长度是该节点的层数，节点都有层数，根所在的层为0

　　　 　树的高度或深度：树的高度或深度是树中节点的最大层数（最长路径的长度）加1 ，空树高度为0，只有根节点的树高度为1

2、二叉树的基本概念

每个节点最多含有两个子树的树称为二叉树；

3、满二叉树

如果一棵树只有度为0与2的节点，且度为0的节点在同一层中，则这颗二叉树为满二叉树。

4、完全二叉树

只有度为0与2的节点，但是度为0的节点可以不位于同一层

5、二叉搜索树

二叉搜索树是有数值的

（1）若其左子树不为空，则左子树上所有的节点的数值均小于他的根节点的数值

（2）若其右子树不为空，则其右子树上所有的节点的数值均小于他的根节点的数值

（3）它的左右子树也分别为二叉排序数

6、平衡二叉树

又称(AVL树， Adelson-Velsky and Landis)，它是一颗空树，或者左右子树的绝对高度差不超过1

7、存储方式

一般为链表与数组两种方式

常见题目多为链表

8、遍历方式

深度优先遍历

​	前序遍历

​	中序遍历

​	后序遍历

​	ps（指的是根的遍历顺序，先遍历根，即为前序遍历，中序后序类似，三种方式都可以使用递归或者迭代的方式实现）

## 144.二叉树的前序遍历

思路：尝试使用非递归的方式来完成该遍历过程

时间：2022-2-24 20:55:25

~~~java
public List<Integer> preorderTraversal(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    List<Integer> ans = new ArrayList<>();
    while (!stack.empty()) {
        TreeNode tmp = stack.pop();
        if (tmp.right != null) {
            stack.push(tmp.right);
        }
        if (tmp.left != null) {
            stack.push(tmp.left);
        }
        ans.add(tmp.val);
    }
    return ans;
}
~~~

时间：2022-2-24 21:14:34

心得：前序遍历，现在感觉较为简单，通过栈模拟递归函数进栈的操作

## 94.二叉树的中序遍历

时间：2022-2-24 21:15:47

~~~java
public List<Integer> inorderTraversal(TreeNode root) {
    //还是通过栈的模拟，不过出栈的时机，与前序遍历的时候不同
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    Stack<TreeNode> stack = new Stack<>();
    TreeNode tmp = root;
    while (tmp != null || !stack.empty()) {
        if (tmp != null) {
            stack.push(tmp);
            tmp = tmp.left;
        } else {
            tmp = stack.pop();
            ans.add(tmp.val);
            tmp = tmp.right;
        }
    }
    return ans;
}
~~~

时间：2022-2-24 21:47:45

心得：上来做的时候，思路错了。想先用一个循环，直接循环到左侧的底部。但是这样做的话，在返回到上一个根节点时，会再次来到根节点的左子节点。因此采用一种办法，使得不会重复遍历根节点。什么条件下，根节点是不需要再次向左侧子节点遍历的？当左侧所有节点全部遍历完成之后。判断左侧全部遍历完的条件是什么？左侧遍历指针为空的时候。这就是所采取的策略

## 145.二叉树的后序遍历

时间：2022-2-24 21:52:49

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    Stack<TreeNode> stack = new Stack();
    TreeNode pre = null;
    TreeNode cur = root;
    while (cur != null || !stack.empty()) {
        if (cur != null) {
            stack.push(cur);
            pre = cur;
            cur = cur.left;
        } else {
            cur = stack.pop();
            if (cur.right == null || cur.right == pre) {
                ans.add(cur.val);
                pre = cur;
                cur = null;
            } else {
                stack.push(cur);
                cur = cur.right;
            }
        }
    }
    return ans;
}
```



心得：这是比较直观的做法，但是最开始还是没有想到解题的思路。还看到一种做法，即先序遍历是中。左。右。

后序遍历是左，右，中。即将先序遍历中的左右顺序颠倒，在将遍历结果整体颠倒，即可得到后序遍历的结果。



## 102.二叉树的层序遍历

时间：2022-2-25 12:54:15

~~~java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    TreeNode cur = root;
    queue.add(cur);
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> tmpAns = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            cur = queue.poll();
            if (cur.left != null) {
                queue.add(cur.left);
            }
            if (cur.right != null) {
                queue.add(cur.right);
            }
            tmpAns.add(cur.val);
        }
        ans.add(tmpAns);
    }
    return ans;
}
~~~

心得：简单二叉树序列化遍历

## 226.反转二叉树

时间：2022-2-25 12:56:54

思路：递归可以做，应该比较简单

~~~java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return root;
    }
    TreeNode tr1 = invertTree(root.left);
    TreeNode tr2 = invertTree(root.right);
    root.left = tr2;
    root.right = tr1;
    return root;
}
~~~

时间：2022-2-25 13:27:35

心得：递归比较简单。

考虑不使用递归的方法。使用栈，模拟递归的过程。弹出栈的时候，改变左右子树的指向关系。与前中后序的非递归遍历类似。

## 101.对称二叉树

时间：2022-2-25 14:14:38

思路：拆成两颗子树，左子树的遍历顺序是左，右，中。右子树的遍历顺序是右，左，中。

~~~java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return compareRoot(root.left, root.right);
}
private boolean compareRoot(TreeNode left, TreeNode right) {
    if (left == null && right != null) {
        return false;
    } else if (left != null && right == null) {
        return false;
    } else if (left == null && right == null) {
        return true;
    }
    if (left.val != right.val) {
        return false;
    }
    boolean bol1 = compareRoot(left.left, right.right);
    boolean bol2 = compareRoot(left.right, right.left);
    return bol1 && bol2;
}
~~~



时间：2022-2-25 14:33:27

心得：思路没啥问题，但是具体写代码的时候有点想不到如何实现。还是需要多写，多练。

考虑也使用层次化遍历的方式来实现。不过还是需要非常注意判断是否为对称时候的条件。

## 104.二叉树的最大深度

时间：2022-2-25 14:38:25

思路：经典简单题目

~~~java
public int maxDepth(TreeNode root) {
    return maxDepthCount(root, 1);
}
private int maxDepthCount(TreeNode root, int count) {
    if (root == null) {
        return count - 1;
    }
    int tmp1 = maxDepthCount(root.left, count + 1);
    int tmp2 = maxDepthCount(root.right, count + 1);
    return Integer.max(tmp1, tmp2);
}
~~~

时间：2022-2-25 14:54:08

心得：虽然是简单题目，但是自增用的不太对，导致存在问题。**再次思考自增的问题**。少用自增这玩意



## 111.二叉树的最小深度

时间：2022-2-25 14:56:30

思路：与最深相似的思路，不过在返回时，返回的是最小值

~~~java
public int minDepth(TreeNode root) {
    int tmp = minDepthCOunt(root, 1);
    return tmp == Integer.MAX_VALUE ? 0 : tmp;
}
private int minDepthCOunt(TreeNode root, int count) {
    if (root != null && root.right == null && root.left == null) {
        return count;
    } else if (root == null) {
        return Integer.MAX_VALUE;
    }
    return Integer.min(minDepthCOunt(root.left, count + 1), minDepthCOunt(root.right, count + 1));
}
~~~

时间：2022-2-25 15:08:15

心得：注意题目条件，深度指的是从根节点到叶节点的长度。在求大深度时不需要考虑判断节点是不是叶节点的问题，因为最大的深度一定是叶节点。但是在求最小深度时，则需要判断返回的该路径是否是到叶节点的路径，即若是叶节点，则正常返回深度值，否则返回最大值。

## 110.平衡二叉树

时间：2022-2-25 15:12:17

思路：类似于求二叉树的深度

~~~java
private boolean isBanencedAns = true;
public boolean isBalanced(TreeNode root) {
    countBalanced(root);
    return isBanencedAns;
}
private int countBalanced(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int num1 = countBalanced(root.left);
    int num2 = countBalanced(root.right);
    int num3 = Math.abs(num1 - num2);
    if (num3 > 1) {
        isBanencedAns = false;
    }
    return Integer.max(num1, num2) + 1;
}
~~~

时间：2022-2-25 15:28:56

心得：我所采用的方法有点破坏了封装性。

考虑不破坏封装性的办法，即返回一个不是基本数据类型的结构。

1、例如返回一个list的结构，每个里面存着上一节点所有子节点的高度的一对数据。最后再统一计算是否符合平衡二叉树的条件？

2、或者采用一个自定义的结构，返回的数据包括子树的最大深度以及子树是否符合平衡二叉树的定义。

感觉第二种相对更合理一点，实现也更加简单一点



## 257.二叉树的所有路径

时间：2022-2-25 15:34:51

思路：经典DFS题目

~~~java
public List<String> binaryTreePaths(TreeNode root) {
    List<String> ans = new ArrayList<>();
    DFSBinaryTreePaths(root, new String(), ans);
    return ans;
}
private void DFSBinaryTreePaths(TreeNode root, String str, List<String> ans) {
    if (root == null){
        return;
    }
    str = str + root.val;
    if (root.right == null && root.left == null) {
        ans.add(str);
        return;
    }
    if (root.left != null) {
        DFSBinaryTreePaths(root.left, str + "->", ans);
    }
    if (root.right != null) {
        DFSBinaryTreePaths(root.right, str + "->", ans);
    }
}
~~~

时间：2022-2-25 16:17:26

心得：还是思路比较简单，但是在写代码的时候，存在不少的细节问题。例如对于递归中的细节问题没有想明白，需要明白递归中哪些变量改变了，哪些没有改变。



## 112.路径总和

时间：2022-2-25 16:20:43

思路：提供一个形参用于记录路径和，提供另一个参数用于记录路径。不对，题目没有要求记录路径，因此仅仅设置一个形参用于计算路径总和即可。

~~~java
public boolean hasPathSum(TreeNode root, int targetSum) {
    return myHasPathSum(root, targetSum, 0);
}
private boolean myHasPathSum(TreeNode root, int target, int tmpSum) {
    if (root != null && root.right == null && root.left == null) {
        if ((tmpSum + root.val) != target) {
            return false;
        } else {
            return true;
        }
    } else if (root == null) {
        return false;
    }
    return myHasPathSum(root.left, target, tmpSum + root.val) || myHasPathSum(root.right, target, tmpSum + root.val);
}
~~~

时间：2022-2-25 16:34:21

心得：简单题目



## 113.路径总和二

时间：2022-2-25 16:35:23

心得：类似上一题，但是增加了记录路径的部分

~~~java
public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    List<List<Integer>> ans = new ArrayList<>();
    myPathSum(root, targetSum, 0, new ArrayList<>(), ans);
    return ans;
}
private void myPathSum(TreeNode root, int target, int tmpSum, List<Integer> tmpAns, List<List<Integer>> ans) {
    if (root == null) {
        return;
    }
    tmpAns.add(root.val);
    List<Integer> tmp = new ArrayList<>();
    for (Integer integer : tmpAns) {
        tmp.add(integer);
    }
    if (root.left == null && root.right == null) {
        if ((tmpSum + root.val) == target) {
            ans.add(tmp);
        }
    }
    myPathSum(root.left, target, tmpSum + root.val, tmpAns, ans);
    myPathSum(root.right, target, tmpSum + root.val, tmpAns, ans);
    tmpAns.remove(tmpAns.size() - 1);
}
~~~

时间：2022-2-25 17:02:07

心得：思路不难，但是需要注意java中List的引用传递。需要开辟新的内存用于保存答案。



## 106.使用中序与后续遍历序列构造二叉树

时间：2022-2-25 17:07:31

思路：找规律的过程。

1、根据后序遍历的最后一个元素确定根节点

2、在中序遍历中，通过根节点将整个序列划分为两个子序列

3、在后续遍历中，从最左侧开始，将整个序列依照中序两个子序列的长度划分为两个子序列。

4、然后中序与后序对应的子序列中重复前三步

~~~java
public TreeNode buildTree(int[] inorder, int[] postorder) {
    if (inorder == null) {
        return new TreeNode();
    }
    return myBuildTree(inorder, postorder);
}
private TreeNode myBuildTree(int[] inorder, int[] postorder) {
    if (inorder.length == 1) {
        return new TreeNode(inorder[0]);
    }
    if (inorder == null || inorder.length == 0) {
        return null;
    }
    TreeNode tmpRoot = new TreeNode(postorder[postorder.length - 1]);
    int i = 0;
    while (inorder[i] != postorder[postorder.length - 1]) {
        i++;
    }
    //System.out.println("i:" + i);
    int[] inorder1 = new int[i];
    int[] inorder2 = new int[inorder.length - 1 - i];
    int[] postorder1 = new int[i];
    int[] postorder2 = new int[inorder.length - 1 - i];
    for (int j = 0; j < i; j++) {
        inorder1[j] = inorder[j];
        postorder1[j] = postorder[j];
    }
    for (int j = 0; j < inorder2.length; j++) {
        //System.out.println("i: " + i + ", j:" + j);
        //System.out.println(inorder.length);
        inorder2[j] = inorder[j + i + 1];
        postorder2[j] = postorder[j + i];
    }
    TreeNode left = myBuildTree(inorder1, postorder1);
    TreeNode right = myBuildTree(inorder2, postorder2);
    tmpRoot.right = right;
    tmpRoot.left = left;
    return tmpRoot;
}
~~~

时间：2022-2-25 17:59:44

心得：思路不难，就是代码有点难写。还有不少可以优化的空间



## 105、根据前序和中序遍历序列构造二叉树

时间：2022-2-25 18:53:55

思路：该题目与前一题最大的不同就在于，在前序遍历中，根节点一定位于第一个

~~~java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder == null) {
        return new TreeNode();
    }
    return myBuildTree(preorder, inorder);
}
private TreeNode myBuildTree(int[] preorder, int[] inorder) {
    if (preorder.length == 1) {
        return new TreeNode(preorder[0]);
    }
    if (preorder == null || preorder.length == 0) {
        return null;
    }
    TreeNode root = new TreeNode(preorder[0]);
    int i = 0;
    while (inorder[i] != preorder[0]) {
        i++;
    }
    int[] inorder1 = new int[i];
    int[] inorder2 = new int[inorder.length - 1 - i];
    int[] preorder1 = new int[i];
    int[] preorder2 = new int[inorder.length - 1 - i];
    for (int j = 0; j < i; j++) {
        inorder1[j] = inorder[j];
        preorder1[j] = preorder[j + 1];
    }
    for (int j = 0; j < (inorder.length - 1 - i); j++) {
        inorder2[j] = inorder[j + i + 1];
        preorder2[j] = preorder[j + i + 1];
    }
    TreeNode left = myBuildTree(preorder1, inorder1);
    TreeNode right = myBuildTree(preorder2, inorder2);
    root.left = left;
    root.right = right;
    return root;
}
~~~

时间：2022-2-25 20:21:27

心得：官方做法https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/



## 617.合并两棵二叉树

时间：2022-2-26 15:20:24

思路：相同的顺序遍历，若是相对应的位置存在着节点，就直接相加，若是没有，则直接拼上。

~~~java
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null) {
        return root2;
    }
    myMergrTrees(root1, root2);
    return root1;
}
private void myMergrTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null || root2 == null) {
        return;
    }
    if (root1 != null && root2 != null) {
        int tmp = root1.val + root2.val;
        root1.val = tmp;
    }

    if (root1.left != null && root2.left != null) {
        myMergrTrees(root1.left, root2.left);
    } else if (root1.left == null && root2.left != null) {
        root1.left = root2.left;
    }
    if (root1.right != null && root2.right != null) {
        myMergrTrees(root1.right, root2.right);
    }  else if (root1.right == null && root2.right != null) {
        root1.right = root2.right;
    }
}
~~~

时间：2022-2-26 15:37:59

心得：主要需要注意的地方就是需要明确递归的边界调节，以及处理不同情况时候的不同操作。



## 700.在二叉搜索树中寻找节点

时间：2022-2-26 15:40:20

思路：简单题目

~~~java
public TreeNode searchBST(TreeNode root, int val) {
    if (root == null) {
        return null;
    }
    if (root.val == val) {
        return root;
    }
    TreeNode tmp1 = searchBST(root.left, val);
    if (tmp1 != null) {
        return tmp1;
    }
    TreeNode tmp2 = searchBST(root.right, val);
    if (tmp2 != null) {
        return tmp2;
    }
    return null;
}
~~~

时间：2022-2-26 15:44:57

心得：代码有不少可以精简的地方，但是现在算是速度联系，暂时先不精简了



## 98.验证二叉搜索树

时间：2022-2-26 15:47:11

思路：采用中序遍历的方式，将二叉树转化为一个数组。判断是不是有序数组

~~~java
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return false;
    }
    List<Integer> tmpAns = new ArrayList<>();
    myIsVailBST(root, tmpAns);
    boolean ans = true;
    if (tmpAns.size() < 2) {
        return ans;
    }
    for (int i = 0; i < tmpAns.size() - 1; i++) {
        int tmp1 = tmpAns.get(i);
        int tmp2 = tmpAns.get(i + 1);
        if (tmp1 >= tmp2) {
            ans = false;
            break;
        }
    }
    return ans;
}
private void myIsVailBST(TreeNode cur, List<Integer> ans) {
    if (cur == null) {
        return;
    }
    myIsVailBST(cur.left, ans);
    ans.add(cur.val);
    myIsVailBST(cur.right, ans);
}
~~~

时间：2022-2-26 16:03:05

心得：官方思路：给左子树设置一个上界，即为根节点；给右子树设置下届，也为根节点；随着不断遍历，不断更新根节点。同时通过判断左右子树是否突破这个界限来判断该子树是不是一个合格的搜索子树。

另外，我最开始的思路，设置一个pre指针，不断指向上一子树的结束位置。我个人认为，这种做法是可以尝试的，但是实现较为复杂。



## 530.二叉搜索树的最小绝对差

时间：2022-2-26 16:09:36

思路：简单题目

```java
private void myIsVailBST(TreeNode cur, List<Integer> ans) {
    if (cur == null) {
        return;
    }
    myIsVailBST(cur.left, ans);
    ans.add(cur.val);
    myIsVailBST(cur.right, ans);
}

//530.二叉搜索树的最小绝对差
public int getMinimumDifference(TreeNode root) {
    if (root == null) {
        return 0;
    }
    List<Integer> tmpAns = new ArrayList<>();
    myIsVailBST(root, tmpAns);
    
    if (tmpAns.size() < 2) {
        return tmpAns.get(0);
    }
    int ans = tmpAns.get(1) - tmpAns.get(0);
    for (int i = 0; i < tmpAns.size() - 1; i++) {
        int tmp1 = tmpAns.get(i + 1) - tmpAns.get(i);
        if (tmp1 < ans) {
            ans = tmp1;
        }
    }
    return ans;
}
```

时间：2022-2-26 16:15:47

心得：做法与上一题基本一致，最后遍历出升序数组后，计算相邻数直接差值的最小值。



## 501.二叉搜索树中的众数

时间：2022-2-26 16:17:58

思路：简单题，用个map记录一下

~~~java
public int[] findMode(TreeNode root) {
    if (root == null) {
        return null;
    }
    Map<Integer, Integer> map = new HashMap<>();
    myFindMode(root, map);
    Iterator iter = map.entrySet().iterator();
    int max = Integer.MIN_VALUE;
    int count = 0;
    while (iter.hasNext()) {
        Map.Entry entry = (Map.Entry) iter.next();
        Integer val = (Integer) entry.getValue();
        //System.out.println(val);
        if (max < val) {
            max = val;
            count = 1;
        } else if (max == val) {
            count++;
        }
    }
    int[] ans = new int[count];
    Iterator iter1 = map.entrySet().iterator();
    int i = 0;
    while (iter1.hasNext()) {
        Map.Entry entry = (Map.Entry) iter1.next();
        Integer val = (Integer) entry.getValue();
        Integer key = (Integer) entry.getKey();
        if (val == max) {
            ans[i] = key;
            i++;
        }
    }
    return ans;

}
private void myFindMode(TreeNode root, Map<Integer, Integer> map) {
    if (root == null) {
        return;
    }
    myFindMode(root.left, map);
    map.put(root.val, map.getOrDefault(root.val, 0) + 1);
    myFindMode(root.right, map);
}
~~~

时间：2022-2-26 16:35:18

心得：过是过了，但是代码的一些逻辑却写的和shit一样，比如获取map中的众数

官方题解：根据搜索二叉树中，相同的数字，在中序遍历的情况下一定连续这样一个性质，不使用哈希表来进行优化https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/



## 236.二叉树的最近公共祖先

时间：2022-2-26 16:41:35

思路：后续遍历，返回一个标定。若是在某个祖先处的左右子树处都获得了标定，则该节点是最近公共祖先

~~~java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null) {
        return null;
    }
    TreeNode tmp1 = lowestCommonAncestor(root.left, p, q);
    TreeNode tmp2 = lowestCommonAncestor(root.right, p, q);
    if (root.val == p.val || root.val == q.val) {
        return root;
    }

    if (tmp1 != null && tmp2 != null && (tmp1.val == p.val || tmp1.val == q.val) && (tmp2.val == p.val || tmp2.val == q.val) && tmp1.val != tmp2.val) {
        return root;
    }
    if (tmp1 != null && (tmp1.val != p.val || tmp1.val != q.val)) {
        return tmp1;
    }
    if (tmp2 != null && (tmp2.val != p.val || tmp2.val != q.val)) {
        return tmp2;
    }
    return null;
}
~~~

时间：2022-2-26 17:03:01

心得：主要是注意返回的条件。与官方思路相似



## 235.二叉搜索树的最近公共祖先

时间：2022-2-26 17:06:32

思路：1、首先是与上一题目一样

2、考虑使用二叉搜索树的特点来进行优化

~~~java
~~~



时间：2022-2-26 17:28:36

心得：优化一下返回值条件的逻辑，与上一题目相比



## 701.在二叉搜索树中插入一个节点

时间：2022-2-28 11:15:50

思路：按照根节点比该值大的时候，遍历左子树，反之遍历右子树的规则，直到遍历到叶子节点，最后将待插入数字插入叶子节点之后。

~~~java
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }
    myInsertIntoBFS(root, val);
    return root;
}
private void myInsertIntoBFS(TreeNode root, int val) {
    if (root == null) {
        return;
    }
    if (root.val > val && root.left == null) {
        root.left = new TreeNode(val);
    }
    if (root.val < val && root.right == null) {
        root.right = new TreeNode(val);
    }

    if (root.val < val) {
        myInsertIntoBFS(root.right, val);
    }
    if (root.val > val)
    {
        myInsertIntoBFS(root.left,val);
    }
}
~~~

时间：2022-2-28 11:53:51

心得：简单题目，考虑通过直接向合法的叶子节点插入目标数值。

考虑二叉树为空的情况，时间返回val创建的二叉树节点。

## 450.在二叉搜索树中删除一个节点

时间：2022-2-28 15:05:40

思路：删除元素分为几种情况：

1、若被删除源元素是叶子节点，则直接将其删除

2、若被删除元素是子树或者树的根节点，则需要考虑不同情况

​	1、若被删除的根仅仅存在一个子树，则直接将子树上移即可。

​	2、若被删除的根存在两个子树，则通常有两种方式可以进场子树根的替代。首先是考虑左子树的最大值，其次的考虑右子树的最小值。从实现的角度来看，左子树的最大值相对容易实现。即增加一个pre指针指向遍历过的上一个元素。

未完成



## 669.修建二叉树

时间：2022-2-28 15:54:38

思路：



# 7、回溯算法

## 回溯一般理解

回溯：是一种搜索方式，野也可以叫做回溯搜索法

​			回溯是递归的副产品，只要有递归，就会存在回溯的过程。

性能：回溯的本质，就是穷举的一种。因此本质上回溯本身的性能非常一般，不是一种非常高效的算法，但是存在部分问题，仅仅只能通过回溯来完成。可以通过剪枝来进行优化。

回溯法一般可以解决的问题：

- 组合问题：按照一定规则在N个数中找出k个数字的集合
- 切割问题：一个字符串，按照一定的规则进行切割，计算切割方式。
- 子集问题：一个N个数字的集合中
- 排列问题：N个数字按照一定的规则，全排列，有几种方式？
- 棋盘问题：N皇后，数独问题。

模板

~~~java
void backTracking(参数) {
    if (终止条件) {
        存放结果；
        return;
    }
    for (选择：本层集合中的元素(树中节点孩子的数量就是集合的大小)) {
        处理节点
            backTracking(路径，选择列表);	//递归
        回溯，撤销处理结果
    }
}

~~~



## 77.组合问题

时间：2022-3-1 12:58:54

思路：直接递归

~~~java
public List<List<Integer>> combine(int n, int k) {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> tmpAns = new ArrayList<>();
    myCombine(n, k, 1, tmpAns, ans);
    return ans;
}
private void myCombine(int n, int k, int startIndex, List<Integer> tmpAns, List<List<Integer>> ans) {
    if (tmpAns.size() == k) {
        List<Integer> tmp = new ArrayList<>(tmpAns);
        ans.add(tmp);
        return;
    }
    for (int i = startIndex; i <= n; i++) {
        tmpAns.add(i);
        myCombine(n, k, i + 1, tmpAns, ans);
        Integer tmp = i;
        tmpAns.remove(tmp);
    }
}
~~~

时间：2022-3-1 13:19:46

心得：注意java中list的复制方式。如果直接将list添加到最终的答案之中，地址始终指向的是list中的内存空间，若是修改list中的数据，那么最终答案集合中的数据也会同时发生改变。

优化过后的算法

~~~java
public List<List<Integer>> combine(int n, int k) {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> tmpAns = new ArrayList<>();
    myCombine(n, k, 1, tmpAns, ans);
    return ans;
}
private void myCombine(int n, int k, int startIndex, List<Integer> tmpAns, List<List<Integer>> ans) {
    if (tmpAns.size() == k) {
        List<Integer> tmp = new ArrayList<>(tmpAns);
        ans.add(tmp);
        return;
    }
    for (int i = startIndex; i <= n - (k - tmpAns.size()) + 1; i++) {
        tmpAns.add(i);
        myCombine(n, k, i + 1, tmpAns, ans);
        Integer tmp = i;
        tmpAns.remove(tmp);
    }
}
~~~

ps: 只有13行的循环结束条件发生的变化



## 216.组合总数三

时间：2022-3-1 14:10:48

思路：同样进行暴力枚举

~~~java
public List<List<Integer>> combinationSum3(int k, int n) {
    List<Integer> tmpAns = new ArrayList<>();
    List<List<Integer>> ans = new ArrayList<>();
    myCombinationSum3(k, n, 1, 0, tmpAns, ans);
    return ans;
}
private void myCombinationSum3(int k, int n, int startIndex, int tmpCount, List<Integer> tmpAns, List<List<Integer>> ans) {
    if (tmpAns.size() == k) {
        if (tmpCount == n) {
            List<Integer> tmp = new ArrayList<>(tmpAns);
            ans.add(tmp);
        }
        return;
    }
    for (int i = startIndex; i <= 9; i++) {
        //if (i <= startIndex + k - tmpAns.size()) {
        tmpAns.add(i);
        myCombinationSum3(k, n, i + 1, tmpCount + i, tmpAns, ans);
        Integer tmp = i;
        tmpAns.remove(tmp);
        //}
    }
}
~~~

时间：2022-3-1 14:32:40

心得：比较奇怪，没有进行剪枝，但是时间仍然超过了100%的人。考虑时间复杂度所有人都是一样的时间复杂度。

剪枝考虑两个方面：

一个是当前的答案总和已经超过了目标值，则后续就不需要进行遍历了。

另一个是从剩余数组的长度开始考虑，若剩余数组的长度，与tmpAns中的长度相加，不足以达到目标长度，在这种情况之下，遍历剩余的情况是没有意义的。



## 17.电话号码的数字组合

时间：2022-3-1 15:01:02

思路：常规回溯题目

~~~java
private String[] telNumber = {"abc", "def", "ghi", "jkl", "nmo", "pqrs", "tuv", "wxyz"};
public List<String> letterCombinations(String digits) {
    List<String> ans = new ArrayList<>();
    if (digits == null || digits.length() == 0) {
        return ans;
    }
    myLetterCombinations(0, digits, new StringBuffer(), ans);
    return ans;
}
private void myLetterCombinations(int curNumber, String digits, StringBuffer tmpAns, List<String> ans) {
    if (digits.length() == tmpAns.length()) {
        ans.add(tmpAns.toString());
        return;
    }
    for (int i = 0; i < telNumber[digits.charAt(curNumber) - '2'].length(); i++) {
        tmpAns.append(telNumber[digits.charAt(curNumber) - '2'].charAt(i));
        myLetterCombinations(curNumber + 1, digits, tmpAns, ans);
        tmpAns.deleteCharAt(tmpAns.length() - 1);
    }
}
~~~

心得：

优化思路：这次似乎不存在优化的思路？因为每一种情况都是必要的，没有不必要的情况发生？



## 39、组合总和

时间：2022-3-1 15:03:37

思路：

~~~java
private List<List<Integer>> ans = new ArrayList<>();
private List<Integer> tmpAns = new ArrayList<>();
public List<List<Integer>> combinationSum(int[] candidates, int target) {

    myCombinationSum(0, candidates, target, 0);
    return ans;
}
private void myCombinationSum(int starIndex, int[] candidates, int target, int tmpSum) {
    if (tmpSum == target) {
        List<Integer> tmp = new ArrayList<>(tmpAns);
        ans.add(tmp);
        return;
    } else if (tmpSum > target) {
        return;
    }
    for (int i = starIndex; i < candidates.length; i++) {
        int tmp = candidates[i];
        tmpAns.add(tmp);
        myCombinationSum(i, candidates, target, tmpSum + candidates[i]);
        tmpAns.remove(tmpAns.size() - 1);
    }
}
~~~

时间：2022-3-1 15:22:47

心得：允许取过的元素可以重复取用，但是取过的元素组合理论上存在唯一的结果，所以取过的元素在进入下一层遍历的时候是不能再次获取的。但是本题目中存在一个例外，那就是当前指向的元素。当前指向的元素是可以重复获取的。

剪枝优化：

1、当前所获取的元素总和已经超过目标值，那么本次就不需要再进行下去了

ps：在17行加了一个判断，从55%到了97%

~~~java
private List<List<Integer>> ans = new ArrayList<>();
private List<Integer> tmpAns = new ArrayList<>();
public List<List<Integer>> combinationSum(int[] candidates, int target) {

    myCombinationSum(0, candidates, target, 0);
    return ans;
}
private void myCombinationSum(int starIndex, int[] candidates, int target, int tmpSum) {
    if (tmpSum == target) {
        List<Integer> tmp = new ArrayList<>(tmpAns);
        ans.add(tmp);
        return;
    } else if (tmpSum > target) {
        return;
    }
    for (int i = starIndex; i < candidates.length; i++) {
        if ((tmpSum + candidates[i]) > target) {
            continue;
        }
        int tmp = candidates[i];

        tmpAns.add(tmp);

        myCombinationSum(i, candidates, target, tmpSum + candidates[i]);
        tmpAns.remove(tmpAns.size() - 1);
    }
}
~~~



## 40.组合总和二

时间：2022-3-1 15:32:14

思路：先进行排序，在同层遍历的时候，将相同的元素跳过去

~~~java
public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> tmpAns = new ArrayList<>();
    Arrays.sort(candidates);
    myCombinationSum2(0, candidates, target, tmpAns, ans, 0);
    return ans;
}
private void myCombinationSum2(int startIndex, int[] candidates, int target, List<Integer> tmpAns, List<List<Integer>> ans,int tmpSum) {
    if (tmpSum == target) {
        List<Integer> tmp = new ArrayList<>(tmpAns);
        ans.add(tmp);
        return;
    } else if (tmpSum > target) {
        return;
    }
    Map<Integer, Integer> mark = new HashMap<>();
    for (int i = startIndex; i < candidates.length; i++) {
        if ((tmpSum + candidates[i]) > target) {
            continue;
        }
        int tmp = candidates[i];
        if (mark.containsKey(tmp)) {
            continue;
        } else {
            mark.put(tmp, 1);
        }
        tmpAns.add(tmp);
        myCombinationSum2(i + 1, candidates, target, tmpAns, ans, tmpSum + tmp);
        tmpAns.remove(tmpAns.size() - 1);
    }
}
~~~



时间：2022-3-1 16:02:53

心得：超过了51%

已优化：对于临时tmpSum > target 的值，直接跳过这一次剩下的数值。

继续优化的条件：



**去重，需要考虑的是在哪个层次对数据进行去重，到底是在树的高度维度还是在树的宽度维度。**



## 131、分割回文串

时间：2022-3-1 16:09:14

思路：

~~~java
private boolean isPalindrome(String str) {
    int i = 0;
    int j = str.length() - 1;
    while (i <= j) {
        if (str.charAt(i) != str.charAt(j)) {
            return false;
        }
        i++;
        j--;
    }
    return true;
}
public List<List<String>> partition(String s) {
    List<List<String>> ans = new ArrayList<>();
    List<String> tmpAns = new ArrayList<>();
    myPartition(0, s, ans, tmpAns);
    return ans;
}
private void myPartition(int startIndex, String s, List<List<String>> ans, List<String> tmpAns) {
    if (startIndex >= s.length()) {
        List<String> tmp = new ArrayList<>(tmpAns);
        ans.add(tmp);
        return;
    }
    for (int i = startIndex; i < s.length(); i++) {
        if (isPalindrome(s.substring(startIndex, i + 1))) {
            tmpAns.add(s.substring(startIndex, i + 1));
            //System.out.println("add: " + s.substring(startIndex, i + 1));
        } else {
            continue;
        }
        myPartition(i + 1, s, ans, tmpAns);
        tmpAns.remove(tmpAns.size() - 1);
    }
}
~~~

时间：2022-3-1 16:56:39

心得：在进行字符串分割的问题的时候，应该注意到进行分割的字符串必定是连续的，因此使用坐标进行递归，可以使得递归过程更加简单。



## 93、复原IP地址

时间：2022-3-1 20:50:24

思路：

~~~java
public List<String> restoreIpAddresses(String s) {
    List<String> ans = new ArrayList<>();
    myRestoreIpAddresses(s, 0, ans, 0, new StringBuffer());
    return ans;
}
private boolean isIP(String str) {
    if (str == null) {
        return false;
    }
    if (str.length() > 1) {
        if (str.charAt(0) == '0') {
            return false;
        }
    } else if (str.length() == 1){
        return true;
    } else {
        return false;
    }
    if (str.length() > 3) {
        return false;
    }
    if (Integer.valueOf(str) > 255) {
        return false;
    }
    return true;
}
private void myRestoreIpAddresses(String s, int startIndex, List<String> ans, int dotNum, StringBuffer stringBuffer) {
    if (dotNum == 3) {  //.的数量为三个时，分割结束
        //判断第四段是否合法
        if (isIP(s.substring(startIndex))) {
            stringBuffer.append(s, startIndex, s.length());
            ans.add(stringBuffer.toString());
        }
        return;
    }
    for (int i = startIndex; i < s.length(); i++) {
        //判断startIndex到i这个区间的字符串是否合法
        if (isIP(s.substring(startIndex, i + 1))) {
            stringBuffer.append(s, startIndex, i + 1);
            stringBuffer.append(".");
            dotNum++;
            myRestoreIpAddresses(s, i + 1, ans, dotNum, stringBuffer);
            dotNum--;
            stringBuffer.delete(startIndex + dotNum, stringBuffer.length());
        } else {
            break;
        }
    }
}
~~~

心得：主要还是做题不熟练，脑瘫在最终添加答案之后多写了一个回溯删除。。。



## 78.子集

时间：2022-3-2 09:31:43

思路：遍历所有子集，不需要设置加入最终答案的条件，而是仅仅将指针向后遍历，因为不存在重复元素，所有仅仅只是向后遍历就不会存在重复的子集。

~~~java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> tmpAns = new ArrayList<>();
    ans.add(tmpAns);
    mySubsets(nums, 0, tmpAns, ans);
    return ans;
}
private void mySubsets(int[] nums, int curIndex, List<Integer> tmpAns, List<List<Integer>> ans) {
    if (curIndex == nums.length) {
        return;
    }
    for (int i = curIndex; i < nums.length; i++) {
        int tmp = nums[i];
        tmpAns.add(tmp);
        List<Integer> tmp1 = new ArrayList<>(tmpAns);
        ans.add(tmp1);
        mySubsets(nums, i + 1, tmpAns, ans);
        tmpAns.remove(tmpAns.size() - 1);
    }
}
~~~

时间：2022-3-2 10:01:40

心得：需要注意List中的传参现象



## 90.子集问题二

时间：2022-3-2 10:04:13

思路：与上一题目相比增加了限制重复元素的条件。不过仅仅是在宽度层面对重复元素进行了限制。

考虑首先进行排序，再在每层遍历的时候将重复元素去除。

~~~java
public List<List<Integer>> subsetsWithDup(int[] nums) {
    List<Integer> tmpAns = new ArrayList<>();
    List<List<Integer>> ans = new ArrayList<>();
    Arrays.sort(nums);
    ans.add(tmpAns);
    mySubsetsWithDup(nums, 0, tmpAns, ans);
    return ans;
}
private void mySubsetsWithDup(int[] nums, int curIndex, List<Integer> tmpAns, List<List<Integer>> ans) {
    if (curIndex == nums.length) {
        return;
    }
    Map<Integer, Integer> mark = new HashMap<>();
    for (int i = curIndex; i < nums.length; i++) {
        if (mark.containsKey(nums[i])) {
            continue;
        } else {
            mark.put(nums[i], 1);
        }
        int tmp1 = nums[i];
        tmpAns.add(tmp1);
        List<Integer> tmp2 = new ArrayList<>(tmpAns);
        ans.add(tmp2);
        mySubsetsWithDup(nums, i + 1, tmpAns, ans);
        tmpAns.remove(tmpAns.size() - 1);
    }
}
~~~

时间：2022-3-2 10:14:15

心得：简单题目。如思路所示



## 491.递增子序列

时间：2022-3-2 10:15:13

思路：先进行排序，在进行子集的获取，在同一层次也存在去重，即在同层遍历的时候，不能遍历相同的元素。加入最终答案的唯一约束条件为答案长度大于1

思路2：题目理解错误，是在现有的顺序基础之上查找递增序列，删除排序部分，将加入临时序列答案，加入递增约束条件。

~~~java
public List<List<Integer>> findSubsequences(int[] nums) {
    List<Integer> tmpAns = new ArrayList<>();
    List<List<Integer>> ans = new ArrayList<>();
    myFindSubsequences(nums, 0, ans, tmpAns);
    return ans;
}
private void myFindSubsequences(int[] nums, int curIndex, List<List<Integer>> ans, List<Integer> tmpAns) {
    if (nums.length == curIndex - 1) {
        return;
    }
    if (tmpAns.size() > 1) {
        List<Integer> tmp = new ArrayList<>(tmpAns);
        ans.add(tmp);
    }
    Map<Integer, Integer> mark = new HashMap<>();
    for (int i = curIndex; i < nums.length; i++) {
        if (mark.containsKey(nums[i])) {
            continue;
        } else {
            mark.put(nums[i], 1);
        }
        if (!tmpAns.isEmpty() && nums[i] < tmpAns.get(tmpAns.size() - 1)) {
            continue;
        }
        tmpAns.add(nums[i]);
        myFindSubsequences(nums, i + 1, ans, tmpAns);
        tmpAns.remove(tmpAns.size() - 1);

    }
}
~~~

时间：2022-3-2 10:56:21

心得：有效小奇怪，不懂得为啥，第一次写的有问题。逻辑应该是没啥问题的。。。



## 46.全排列

时间：2022-3-2 10:57:34

思路：在深度上去重，宽度上没有要求

```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> tmpAns = new ArrayList<>();
    int[] mark = new int[nums.length];
    myPermute(nums, tmpAns, ans, 0, mark);
    return ans;
}
private void myPermute(int[] nums, List<Integer> tmpAns, List<List<Integer>> ans, int curIndex, int[] mark) {
    if (curIndex == nums.length) {
        List<Integer> tmp = new ArrayList<>(tmpAns);
        ans.add(tmp);
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if (mark[i] == 0) {
            tmpAns.add(nums[i]);
            mark[i] = 1;
            myPermute(nums, tmpAns, ans, curIndex + 1, mark);
            mark[i] = 0;
            tmpAns.remove(tmpAns.size() - 1);
        }
    }
}
```

时间：2022-3-2 11:16:49

心得：在深度的维度上进行去重。



## 47.排列问题二

时间：2022-3-2 11:38:43

思路：从深度与宽度两个维度进行去重

~~~java
public List<List<Integer>> permuteUnique(int[] nums) {
    List<Integer> tmpAns = new ArrayList<>();
    List<List<Integer>> ans = new ArrayList<>();
    int[] deepMark = new int[nums.length];
    myPermuteUnique(0, nums, tmpAns, ans, deepMark);
    return ans;
}
private void myPermuteUnique(int curIndex, int[] nums, List<Integer> tmpAns, List<List<Integer>> ans, int[] deepMark) {
    if (curIndex == nums.length) {
        List<Integer> tmp = new ArrayList<>(tmpAns);
        ans.add(tmp);
        return;
    }
    Map<Integer, Integer> wideMark = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (deepMark[i] == 0) {
            if (wideMark.containsKey(nums[i])) {
                continue;
            } else {
                wideMark.put(nums[i], 1);
            }
            tmpAns.add(nums[i]);
            deepMark[i] = 1;
            myPermuteUnique(curIndex + 1, nums, tmpAns, ans, deepMark);
            deepMark[i] = 0;
            tmpAns.remove(tmpAns.size() - 1);
        }
    }
}
~~~

时间：2022-3-2 11:47:31

心得：时间复杂度打败百分之四十多。参考一下官方解法

官方：



## 51.N皇后问题

时间：2022-3-2 16:26:50

思路：从深度与宽度两个维度来考虑，树的深度就是二维矩阵的高度，树的宽度就是二维矩阵的宽度。

~~~java
public List<List<String>> solveNQueens(int n) {
    List<List<String>> ans = new ArrayList<>();
    List<String> tmpAns = new ArrayList<>();
    StringBuffer tmp = new StringBuffer();
    for (int i = 0; i < n; i++) {
        tmp.append(".");
    }
    mySolveNQueens(tmpAns, 0, n, ans, tmp, 0);
    return ans;
}
private boolean isSolveNQueens(List<String> str, int row, int col, int n) {
    //检查列
    for (int i = 0; i < row; i++) {
        if (str.get(i).charAt(col) == 'Q') {
            return false;
        }
    }
    //检查-45对角线
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
        if (str.get(i).charAt(j) == 'Q') {
            return false;
        }
    }
    //检查45对角线
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (str.get(i).charAt(j) == 'Q') {
            return false;
        }
    }
    return true;
}
private void mySolveNQueens(List<String> tmpAns, int row, int n, List<List<String>> ans, StringBuffer stringBuffer, int count) {
    if (row == n && count == n) {
        List<String> tmp = new ArrayList<>(tmpAns);
        ans.add(tmp);
        return;
    }
    for (int col = 0; col < n; col++) {
        if (isSolveNQueens(tmpAns, row, col, n)) {
            stringBuffer.replace(col, col + 1, "Q");
            tmpAns.add(stringBuffer.toString());
            stringBuffer.replace(col, col + 1, ".");
            mySolveNQueens(tmpAns, row + 1, n, ans, stringBuffer, count + 1);
            tmpAns.remove(tmpAns.size() - 1);
        }
    }
}
~~~

心得：时间复杂度超33%，还有进一步优化的空间，但是今天脑子不太想动了，下次一定



# 8、贪心算法

## 455.分发饼干

时间：2022-3-3 13:54:39

思路：简单题目

~~~java
public int findContentChildren(int[] g, int[] s) {
    Arrays.sort(g);
    Arrays.sort(s);
    int j = 0;
    int count = 0;
    for (int i = 0; i < g.length; i++) {
        while (j < s.length && g[i] > s[j]) {
            j++;
        }
        if (j >= s.length) {
            break;
        }
        if (g[i] <= s[j]) {
            count++;
        }
        j++;
    }
    return count;
}
~~~





## 376.摆动序列

时间：2022-3-3 13:55:32

思路：

~~~java
public int wiggleMaxLength(int[] nums) {
    if (nums.length < 3) {
        if (nums.length == 2) {
            if (nums[0] != nums[1]) {
                return 2;
            }
        }
        return 1;
    }
    ArrayList<Integer> tmpAns = new ArrayList();
    for (int i : nums) {
        tmpAns.add(i);
    }
    int i = 1;
    while (i < tmpAns.size() - 1) {
        if (isValue((tmpAns.get(i) - tmpAns.get(i - 1)), (tmpAns.get(i + 1) - tmpAns.get(i)))) {
            i++;
        } else {
            tmpAns.remove(i);
        }
        if (tmpAns.size() == 2 && tmpAns.get(0).equals(tmpAns.get(1))) {
            return 1;
        }
    }
    return tmpAns.size();
}
private boolean isValue(int tmp1, int tmp2) {
    if ((tmp1 < 0 && tmp2 > 0) || (tmp1 > 0 && tmp2 < 0)) {
        return true;
    }
    return false;
}
~~~

心得：感觉个人写的逻辑存在一点问题。后期再优化一下。



## 53.最大子数组和

时间：2022-3-3 19:31:38

心得：直接双层循环进行暴力遍历，暴力解法超时，n方的时间复杂度。

贪心：从头遍历num，采用count存储累计和。count若为负值，则立马放弃count的累计计算值，count从头开始计算。因为无论后面一段的累计和是什么，加上之前的负值，那么一定会更小，不加负值反而会更大。

~~~java
public int maxSubArray(int[] nums) {
    long max = (long)Integer.MIN_VALUE;
    long count = 0;
    for (int i = 0; i < nums.length; i++) {
        count += nums[i];
        if (count > max) {
            max = count;
        }
        if (count < 0) {
            count = 0;
        }
    }
    return (int)max;
}
~~~

时间：2022-3-3 19:57:35

心得：参考了Carl的代码。慢慢体会贪心的思想。

后面还有这个题目动态规划的做法

## 122.买卖股票的最佳时机二

时间：2022-3-3 19:58:53

思路：不断寻找递增序列，并累计加和递增序列最小值与最大值的差值。即为最大利润

~~~java
public int maxProfit(int[] prices) {
    if (prices.length == 0) {
        return 0;
    }
    int ans = 0;
    int tmpMin = 0;
    int count = 0;  //用于标记递增子序列的长度
    for (int i = 1; i < prices.length; i++) {
        if (prices[i - 1] <= prices[i]) {
            if (count == 0) {
                tmpMin = prices[i - 1];
            }
            count++;

        } 
        if (count > 0 && prices[i - 1] > prices[i]){
            ans += (prices[i - 1] - tmpMin);
            count = 0;
            continue;
        }
        if (count > 0 && i == prices.length - 1) {
            ans += (prices[i] - tmpMin);
        }
    }
    return ans;
}
~~~

时间：2022-3-3 20:26:05

心得：需要注意一下，在一个完全递增的序列中，需要进行一个特殊的处理。



## 55.跳跃游戏

时间：2022-3-3 20:40:11

思路：转换为计算覆盖范围的问题，通过计算覆盖范围的最大值，只要覆盖范围大于等于数组的长度即可。

~~~java
public boolean canJump(int[] nums) {
    if (nums.length == 1) {
        return true;
    }
    int ans = 0;
    for (int i = 0; i <= ans; i++) {
        ans = Integer.max(i + nums[i], ans);
        if (ans >= nums.length - 1) {
            return true;
        }
    }
    return false;
}
~~~

时间：2022-3-3 21:23:12

心得：参考了Carl哥的做法。



## 45.跳跃游戏二

时间：2022-3-3 21:42:20

思路：参考Carl的做法，p320

~~~java
public int jump(int[] nums) {
    if (nums.length == 1) {
        return 0;
    }
    int curCover = 0;   //当前覆盖的最远距离的下标
    int ans = 0;    //记录已经走过的步数
    int nextCover = 0;  //下一步覆盖的最远距离的下标
    for (int i = 0; i < nums.length; i++) {
        //更新下一步覆盖的最远距离的下标
        nextCover = Math.max(i + nums[i], nextCover);
        //遇到当前覆盖最远的下标
        if (i == curCover) {
            if (curCover != nums.length - 1) {
                //走下一步
                ans++;
                curCover = nextCover;
                if (nextCover >= nums.length - 1) {
                    break;
                }
            } else {
                break;
            }
        }
    }
    return ans;
}
~~~

心得：必须得重做



## 134.加油站

时间：2022-3-4 13:16:34

思路：直接暴力双循环，超时

参考Carl的思路

- 从全局最优思考
  - 如果gas总和是小于cost总和的，那么无论是哪种方案，一定不能完成一圈
  - res[i] = gas[i] - cost[i]为从当前站出发之后所剩余的gas，从头开始计算，若是剩余gas的累加和一直大于0，则表明，0即为最终结果
  - 若存在gas累加和小于0的情况，则表明从使得gas累加小于0的节点开始从新计算开始路径。

~~~java
public int canCompleteCircuit(int[] gas, int[] cost) {
    int curSum = 0;
    int min = Integer.MAX_VALUE;
    //首先从0开始遍历一遍，统计累计邮箱剩余油量最小的时候，以及累计消耗的总和是否小于加油站累计的总和
    for (int i = 0; i < gas.length; i++) {
        int tmpSum = gas[i] - cost[i];
        curSum += tmpSum;
        if (min > curSum) {
            min = curSum;
        }
    }
    if (curSum < 0) {   //若是一圈的加油量是小于消耗量的，那么无论如何也是跑不完一圈的

        return  -1;
    }
    if (min >= 0) {     //若是一圈中任何时刻的当前油箱的剩余数量都是大于0的，那么从头开始就是一种解决方案
        return 0;
    }
    for (int i = gas.length - 1; i >= 0 ; i--) {
        int tmp = gas[i] - cost[i];
        min += tmp;
        if (min >= 0) {
            return i;
        }
    }
    return -1;
}
~~~

心得：Carl做法，还得熟悉





## 135.分发糖果

时间：2022-3-4 16:12:58

思路：困难。

遍历两遍，两遍需要是相反的方向。

- 首先是从左向右遍历，在遍历的过程中，确定每个元素与其右侧元素的相对关系。若是右侧元素比左侧的，则右侧元素则加1
- 其次是从右向左遍历，若是左侧元素比右侧元素大，则左侧元素加1













